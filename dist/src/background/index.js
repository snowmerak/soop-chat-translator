var g=Object.defineProperty;var p=(e,a,r)=>a in e?g(e,a,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[a]=r;var h=(e,a,r)=>p(e,typeof a!="symbol"?a+"":a,r);import{D as m}from"../../chunks/defaults-hrsvWvRM.js";class S{constructor(a,r,t){h(this,"baseUrl");h(this,"model");h(this,"apiKey");this.baseUrl=a.replace(/\/$/,""),this.model=r,this.apiKey=t}async translate(a,r,t){const n=t&&t!=="Auto"?` ${t} `:" ",u={model:this.model,messages:[{role:"user",content:`Translate this${n}chat message to ${r}. You MUST output strictly in JSON format like this: {"translation": "..."}
Do not add any explanation or notes.
Message:
${a}`}],temperature:.1,top_p:.95,max_completion_tokens:128,stream:!1,ngl:999,enable_think:!1,enable_json:!0},i={"Content-Type":"application/json"};this.apiKey&&(i.Authorization=`Bearer ${this.apiKey}`);const l=await fetch(`${this.baseUrl}/v1/chat/completions`,{method:"POST",headers:i,body:JSON.stringify(u)});if(!l.ok)throw new Error(`API ${l.status}: ${l.statusText}`);let s=(await l.json()).choices?.[0]?.message?.content?.trim();if(!s)throw new Error("Empty response from API");try{s.startsWith("```json")?s=s.replace(/^\`\`\`json\s*/,"").replace(/\s*\`\`\`$/,""):s.startsWith("```")&&(s=s.replace(/^\`\`\`\s*/,"").replace(/\s*\`\`\`$/,""));const o=JSON.parse(s);if(o.translation)return o.translation}catch{console.warn("[SOOP Translator] Failed to parse JSON, falling back to raw output:",s)}return s}}const y=500,c=new Map;function w(e){const a=c.get(e);return a!==void 0&&(c.delete(e),c.set(e,a)),a}function d(e,a){if(c.size>=y){const r=c.keys().next().value;r!==void 0&&c.delete(r)}c.set(e,a)}async function $(){return new Promise(e=>{chrome.storage.local.get(m,a=>{e(a)})})}function T(e){switch(e){case"Korean":return"ko";case"English":return"en";case"Japanese":return"ja";case"Chinese (Simplified)":return"zh";case"Spanish":return"es";case"French":return"fr";default:return""}}chrome.runtime.onMessage.addListener((e,a,r)=>e.type!=="TRANSLATE"?!1:((async()=>{try{const t=await $();if(!t.enabled){r({success:!1,error:"Translation is disabled"});return}const n=`${t.targetLang}::${e.text}`,u=w(n);if(u!==void 0){r({success:!0,result:u,cached:!0});return}const i=T(t.targetLang);if(i){const s=await new Promise(o=>{chrome.i18n.detectLanguage(e.text,o)});if(s&&s.isReliable&&s.languages.length>0){const o=s.languages[0].language;if(o===i||o.startsWith(i)){d(n,e.text),r({success:!0,result:e.text,cached:!1,skipped:!0});return}}}const l=new S(t.apiBase,t.model,t.apiKey);console.log(`[SOOP Translator] Sending API request to: ${t.apiBase} | Model: ${t.model} | Source: ${t.sourceLang} -> Target: ${t.targetLang}`);const f=await l.translate(e.text,t.targetLang,t.sourceLang);d(n,f),r({success:!0,result:f,cached:!1})}catch(t){const n=t instanceof Error?t.message:"Unknown error";console.error("[SOOP Translator] Error:",n),r({success:!1,error:n})}})(),!0));
